# Binary Search Tree with Recursion
This program implements a binary search tree (BST) using recursion. As a binary tree, each node has a maximum of two children. The following two rules distinguish it from a normal binary tree: For each node *n*,
<ol>
<li>every element of *n*'s left subtree must be less than or equal to the element in node *n*, and</li>
<li>every element of *n*'s right subtree must be greater than the element in node *n*.</li>
</ol>

## Specification

In this assignment, the student must build a BST with integer values, implementing insertion and deletion of nodes with recursion, and then print the three traversals (pre-, in-, and post-order). Additionally, a person using the program must be able to insert or delete a value and to find the predecessor or successor of a given value. Notably, when inserting, no duplicates are allowed in the tree. After every change to the tree, the program must print the BST in-order. Lastly, the program should be relatively intuitive, which includes, but is not limited to, a help menu.

In my project, insertion and deletion of nodes is done recursively using the methods, `add(int, BTNode)` and `remove(int, BTNode)`. The traversals are handled with the three methods, `preOrderTrav(BTNode)`, `inOrderTrav(BTNode)`, and `inOrderTrav(BTNode)`, which are also recursive. The predecessor and successor are provided in the methods `getPredecessor(int, BTNode)` and `getSuccessor(int, BTNode)`, respectfully. To implement these, I used a handful of supporting methods to keep it organized and for code reuse. They were used for finding key nodes that are necessary for the functions, such as finding the rightmost node of a given subjective root or finding a certain ancestral relationship. The nodes themselves were represented by `BTNode`, which have the fields `data`, `left`, `right`, and `parent`, and appropriate getter and setter methods. As for the user interface, I included a help menu and ensured that the initial values of the tree were all integers. For the rest, the only accepted inputs were either the single-letter commands, `H` and `E`, which could be upper- or lower-case, or the combinations, `I`, `D`, `P`, or `S`, paired with an integer next. If input failed to meet the requirements, a message would be printed to the user. However, the conditions were somewhat lenient in that as long as the first character of the first section (before the space) of the command is `I`, `D`, `P`, or `S`, it would be accepted.
